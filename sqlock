#!/bin/bash
# mutex for distributed tasks, ideally suited for cron tasks
# that might otherwise run on duplicate servers in a cluster unnecessarily
#
# usage: sqlock command args
#
# Tries to get a lock to run command plus its arguments; if the lock is
# successful, the command will be run, if not, we exit.
#
# Uses Mysql's GET_LOCK() function
set -eu

# How long to wait to see if we successfully got the lock.
# Don't set to a negative value, as mysql will wait forever.
LOCKTIMEOUT_SECONDS=1 # you can edit this

# Mysql credentials - you can edit these
MYSQL_USER=root
MYSQL_PASSWORD=
MYSQL_HOST=127.0.0.1

# Set up Mysql credentials. Will use -p$MYSQL_PASSWORD if you've
# defined MYSQL_PASSWORD, otherwise will use a passwordless connection
MYSQL_CREDENTIALS="-u $MYSQL_USER -h $MYSQL_HOST"
if [ -n "$MYSQL_PASSWORD" ]; then
  MYSQL_CREDENTIALS="$MYSQL_CREDENTIALS -p$MYSQL_PASSWORD"
fi

# convert our arguments into a string we can use to get the lock with
lockstring="${@//[^[:alpha:]]/_}"

# Make a fifo in a random temp folder
tmpdir=$(mktemp -d) && {
  fifo="$tmpdir/fifo"
  mkfifo "$fifo"
}

# tail the fifo to keep it open, pipe to mysql in unbuffered mode
# and capture the output
tail -f "$fifo" | mysql --unbuffered $MYSQL_CREDENTIALS -N > "$tmpdir"/sql.log &

# save the PID so we can kill it later
mysqlpid=$!

# Now try and get the lock
echo "SELECT IF(GET_LOCK('$lockstring',$LOCKTIMEOUT_SECONDS)=1,'Got lock', concat('Already locked by connection: ', IS_USED_LOCK('$lockstring')));" >$fifo

# Sleep for long enough to see whether we got the lock
sleep $LOCKTIMEOUT_SECONDS
grep -q "Got lock" "$tmpdir"/sql.log || (>&2 echo "Didn't get the lock"; kill $mysqlpid; rm -rf "$tmpdir"; exit 1)

# If we're still running, we got the lock, so now execute the commands
# that were passed to us:
"$@"

# release the lock
echo "SELECT RELEASE_LOCK('$lockstring');" >$fifo

# kill the mysql tail
kill $mysqlpid;

# remove the tmpdir with the fifo and log
rm -rf "$tmpdir"
